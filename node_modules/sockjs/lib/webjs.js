(function() {
  var WebJS, execute_request, fs, http, querystring, url, utils;
  url = require('url');
  querystring = require('querystring');
  fs = require('fs');
  http = require('http');
  utils = require('./utils');
  execute_request = function(app, funs, req, res, data) {
    var fun, _results;
    try {
      _results = [];
      while (funs.length > 0) {
        fun = funs.shift();
        req.last_fun = fun;
        _results.push(data = app[fun](req, res, data, req.next_filter));
      }
      return _results;
    } catch (x) {
      if (typeof x === 'object' && 'status' in x) {
        if (x.status === 0) {
          return true;
        } else if ('handle_' + x.status in app) {
          return app['handle_' + x.status](req, res, x);
        } else {
          return app.handle_error(req, res, x);
        }
      } else {
        return app.handle_error(req, res, x);
      }
    }
  };
  WebJS = (function() {
    function WebJS(app, dispatcher) {
      this.app = app;
      this.dispatcher = dispatcher;
    }
    WebJS.prototype.handler = function(req, res, head) {
      var allowed_methods, found, funs, headers, i, m, method, path, row, that, _i, _len, _ref, _ref2;
      that = this;
      utils.objectExtend(req, url.parse(req.url, true));
      found = false;
      allowed_methods = [];
      _ref = this.dispatcher;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        method = row[0], path = row[1], funs = row[2];
        if (path.constructor !== Array) {
          path = [path];
        }
        m = req.pathname.match(path[0]);
        if (!m) {
          continue;
        }
        if (req.method !== method) {
          allowed_methods.push(method);
          continue;
        }
        for (i = 1, _ref2 = path.length; 1 <= _ref2 ? i < _ref2 : i > _ref2; 1 <= _ref2 ? i++ : i--) {
          req[path[i]] = m[i];
        }
        if (typeof res.writeHead === "undefined") {
          headers = [];
          res.writeHead = function(status, user_headers, content) {
            var r;
            r = [];
            r.push('HTTP/' + req.httpVersion + ' ' + status + ' ' + http.STATUS_CODES[status]);
            if (user_headers && user_headers.length > 0) {
              r = r.concat(user_headers);
            }
            if (headers && headers.length > 0) {
              r = r.concat(headers);
            }
            r = r.concat(['', '']);
            if (content) {
              r.push(content);
            }
            try {
              return res.write(r.join('\r\n'));
            } catch (e) {
              return null;
            }
          };
          res.setHeader = function(k, v) {
            return headers.push(k + ': ' + v);
          };
        }
        req.start_date = new Date();
        funs = funs.slice(0);
        funs.push('log');
        req.next_filter = function(data) {
          return execute_request(that.app, funs, req, res, data);
        };
        req.next_filter(head);
        found = true;
        break;
      }
      if (!found) {
        if (allowed_methods.length !== 0) {
          that.app.handle_405(req, res, allowed_methods);
        } else {
          return false;
        }
      }
      return true;
    };
    return WebJS;
  })();
  exports.WebJS = WebJS;
  exports.generic_app = {
    handle_404: function(req, res, x) {
      if (res.finished) {
        return x;
      }
      res.writeHead(404, {});
      res.end("404 - Not Found");
      return true;
    },
    handle_405: function(req, res, methods) {
      res.writeHead(405, {
        'Allow': methods.join(', ')
      });
      res.end("405 - Method Not Alloweds");
      return true;
    },
    handle_error: function(req, res, x) {
      if (res.finished) {
        return x;
      }
      if (typeof x === 'object' && 'status' in x) {
        res.writeHead(x.status, {});
        res.end("" + x.status + " " + x.message);
      } else {
        try {
          res.writeHead(500, {});
          res.end("500 - Internal Server Error");
        } catch (y) {

        }
        console.log('Caught error on "' + req.method + ' ' + req.href + '', '" in filter "' + req.last_fun + '":\n' + (x.stack || x));
      }
      return true;
    },
    log: function(req, res, data) {
      var td;
      td = (new Date()) - req.start_date;
      console.log(req.method, req.url, td, 'ms', res.finished ? res._header.split('\r')[0] : '(unfinished)');
      return data;
    },
    expose_html: function(req, res, content) {
      if (res.finished) {
        return content;
      }
      if (!res.getHeader('Content-Type')) {
        res.setHeader('Content-Type', 'text/html; charset=UTF-8');
      }
      return this.expose(req, res, content);
    },
    expose_json: function(req, res, content) {
      if (res.finished) {
        return content;
      }
      if (!res.getHeader('Content-Type')) {
        res.setHeader('Content-Type', 'application/json');
      }
      return this.expose(req, res, JSON.stringify(content));
    },
    expose: function(req, res, content) {
      if (res.finished) {
        return content;
      }
      if (content && !res.getHeader('Content-Type')) {
        res.setHeader('Content-Type', 'text/plain');
      }
      if (content) {
        res.setHeader('Content-Length', content.length);
      }
      res.writeHead(res.statusCode);
      res.end(content, 'utf8');
      return true;
    },
    serve_file: function(req, res, filename, next_filter) {
      var a;
      a = function(error, content) {
        if (error) {
          res.writeHead(500);
          res.end("can't read file");
        } else {
          res.setHeader('Content-length', content.length);
          res.writeHead(res.statusCode, res.headers);
          res.end(content, 'utf8');
        }
        return next_filter(true);
      };
      fs.readFile(filename, a);
      throw {
        status: 0
      };
    },
    cache_for: function(req, res, content) {
      var exp;
      res.cache_for = res.cache_for || 365 * 24 * 60 * 60;
      res.setHeader('Cache-Control', 'public, max-age=' + res.cache_for);
      exp = new Date();
      exp.setTime(exp.getTime() + res.cache_for * 1000);
      res.setHeader('Expires', exp.toGMTString());
      return content;
    },
    h_no_cache: function(req, res, content) {
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0');
      return content;
    },
    expect_form: function(req, res, _data, next_filter) {
      var data;
      data = new Buffer(0);
      req.on('data', function(d) {
        return data = utils.buffer_concat(data, new Buffer(d, 'binary'));
      });
      req.on('end', function() {
        var q;
        data = data.toString('utf-8');
        switch ((req.headers['content-type'] || '').split(';')[0]) {
          case 'application/x-www-form-urlencoded':
            q = querystring.parse(data);
            break;
          case 'text/plain':
          case '':
            q = data;
            break;
          default:
            console.log("unsupported content-type", req.headers['content-type']);
            q = void 0;
        }
        return next_filter(q);
      });
      throw {
        status: 0
      };
    },
    expect_xhr: function(req, res, _data, next_filter) {
      var data;
      data = new Buffer(0);
      req.on('data', function(d) {
        return data = utils.buffer_concat(data, new Buffer(d, 'binary'));
      });
      req.on('end', function() {
        var q;
        data = data.toString('utf-8');
        switch ((req.headers['content-type'] || '').split(';')[0]) {
          case 'text/plain':
          case 'T':
          case 'application/json':
          case 'application/xml':
          case '':
            q = data;
            break;
          default:
            console.log("unsupported content-type", req.headers['content-type']);
            q = void 0;
        }
        return next_filter(q);
      });
      throw {
        status: 0
      };
    },
    h_sid: function(req, res, data) {
      var cookie, jsid, parts, _i, _len, _ref;
      req.cookies = {};
      if (req.headers.cookie) {
        _ref = req.headers.cookie.split(';');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cookie = _ref[_i];
          parts = cookie.split('=');
          req.cookies[parts[0].trim()] = (parts[1] || '').trim();
        }
      }
      if (res.setHeader) {
        jsid = req.cookies['JSESSIONID'] || 'a';
        res.setHeader('Set-Cookie', 'JSESSIONID=' + jsid + '; path=/');
      }
      return data;
    }
  };
}).call(this);
