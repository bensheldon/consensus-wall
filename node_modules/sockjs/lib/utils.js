(function() {
  var array_intersection, crypto;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  crypto = require('crypto');
  exports.array_intersection = array_intersection = function(arr_a, arr_b) {
    var a, r, _i, _len;
    r = [];
    for (_i = 0, _len = arr_a.length; _i < _len; _i++) {
      a = arr_a[_i];
      if (arr_b.indexOf(a) !== -1) {
        r.push(a);
      }
    }
    return r;
  };
  exports.verify_origin = function(origin, list_of_origins) {
    var origins, parts;
    if (list_of_origins.indexOf('*:*') !== -1) {
      return true;
    }
    if (!origin) {
      return false;
    }
    try {
      parts = url.parse(origin);
      origins = [parts.host + ':' + parts.port, parts.host + ':*', '*:' + parts.port];
      if (array_intersection(origins, list_of_origins).length > 0) {
        return true;
      }
    } catch (x) {
      null;
    }
    return false;
  };
  exports.escape_selected = function(str, chars) {
    var c, i, map, parts, r, v, _i, _len, _ref;
    map = {};
    chars = '%' + chars;
    for (_i = 0, _len = chars.length; _i < _len; _i++) {
      c = chars[_i];
      map[c] = escape(c);
    }
    r = new RegExp('([' + chars + '])');
    parts = str.split(r);
    for (i = 0, _ref = parts.length; 0 <= _ref ? i < _ref : i > _ref; 0 <= _ref ? i++ : i--) {
      v = parts[i];
      if (v.length === 1 && v in map) {
        parts[i] = map[v];
      }
    }
    return parts.join('');
  };
  exports.buffer_concat = function(buf_a, buf_b) {
    var dst;
    dst = new Buffer(buf_a.length + buf_b.length);
    buf_a.copy(dst);
    buf_b.copy(dst, buf_a.length);
    return dst;
  };
  exports.md5_hex = function(data) {
    return crypto.createHash('md5').update(data).digest('hex');
  };
  exports.sha1_base64 = function(data) {
    return crypto.createHash('sha1').update(data).digest('base64');
  };
  exports.timeout_chain = function(arr) {
    var fun, timeout, user_fun, _ref;
    arr = arr.slice(0);
    if (!arr.length) {
      return;
    }
    _ref = arr.shift(), timeout = _ref[0], user_fun = _ref[1];
    fun = __bind(function() {
      user_fun();
      return exports.timeout_chain(arr);
    }, this);
    return setTimeout(fun, timeout);
  };
  exports.objectExtend = function(dst, src) {
    var k;
    for (k in src) {
      if (src.hasOwnProperty(k)) {
        dst[k] = src[k];
      }
    }
    return dst;
  };
}).call(this);
