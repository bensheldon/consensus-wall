(function() {
  var ConnectionReceiver, GenericReceiver, MAP, ResponseReceiver, Session, Transport, closeFrame, events, keepalive_delay, uuid;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  events = require('events');
  uuid = require('node-uuid');
  Transport = (function() {
    function Transport() {}
    return Transport;
  })();
  Transport.CONNECTING = 0;
  Transport.OPEN = 1;
  Transport.CLOSING = 2;
  Transport.CLOSED = 3;
  closeFrame = function(status, reason) {
    return 'c' + JSON.stringify([status, reason]);
  };
  keepalive_delay = 25000;
  MAP = {};
  Session = (function() {
    __extends(Session, events.EventEmitter);
    function Session(session_id, server) {
      this.session_id = session_id;
      this.id = uuid();
      this.send_buffer = [];
      this.is_closing = false;
      this.readyState = Transport.CONNECTING;
      if (this.session_id) {
        MAP[this.session_id] = this;
      }
      this.timeout_cb = __bind(function() {
        return this.didTimeout();
      }, this);
      this.to_tref = setTimeout(this.timeout_cb, 5000);
      this.emit_open = __bind(function() {
        this.emit_open = null;
        return server.emit('open', this);
      }, this);
    }
    Session.prototype.register = function(recv) {
      if (this.recv) {
        recv.doSendFrame(closeFrame(2010, "Another connection still open"));
        return;
      }
      if (this.to_tref) {
        clearTimeout(this.to_tref);
        this.to_tref = null;
      }
      if (this.readyState === Transport.CLOSING) {
        recv.doSendFrame(this.close_frame);
        this.to_tref = setTimeout(this.timeout_cb, 5000);
        return;
      }
      this.recv = recv;
      this.recv.session = this;
      if (this.readyState === Transport.CONNECTING) {
        this.recv.doSendFrame('o');
        this.readyState = Transport.OPEN;
        process.nextTick(this.emit_open);
      }
      if (!this.recv) {
        return;
      }
      this.tryFlush();
    };
    Session.prototype.unregister = function() {
      this.recv.session = null;
      this.recv = null;
      if (this.to_tref) {
        clearTimeout(this.to_tref);
      }
      return this.to_tref = setTimeout(this.timeout_cb, 5000);
    };
    Session.prototype.tryFlush = function() {
      var sb, x, _ref;
      if (this.send_buffer.length > 0) {
        _ref = [this.send_buffer, []], sb = _ref[0], this.send_buffer = _ref[1];
        this.recv.doSendBulk(sb);
      } else {
        if (this.to_tref) {
          clearTimeout(this.to_tref);
        }
        x = __bind(function() {
          if (this.recv) {
            this.to_tref = setTimeout(x, keepalive_delay);
            return this.recv.doSendFrame("h");
          }
        }, this);
        this.to_tref = setTimeout(x, keepalive_delay);
      }
    };
    Session.prototype.didTimeout = function() {
      if (this.readyState !== Transport.CONNECTING && this.readyState !== Transport.OPEN && this.readyState !== Transport.CLOSING) {
        throw Error('INVALID_STATE_ERR');
      }
      if (this.recv) {
        throw Error('RECV_STILL_THERE');
      }
      this.readyState = Transport.CLOSED;
      this.emit('close', {
        status: 1001,
        reason: "Session timeouted"
      });
      if (this.session_id) {
        delete MAP[this.session_id];
        return this.session_id = null;
      }
    };
    Session.prototype.didMessage = function(payload) {
      if (this.readyState === Transport.OPEN) {
        this.emit('message', {
          data: payload
        });
      }
    };
    Session.prototype.send = function(payload) {
      if (this.readyState !== Transport.OPEN) {
        throw Error('INVALID_STATE_ERR');
      }
      this.send_buffer.push(payload);
      if (this.recv) {
        return this.tryFlush();
      }
    };
    Session.prototype.close = function(status, reason) {
      if (status == null) {
        status = 1000;
      }
      if (reason == null) {
        reason = "Normal closure";
      }
      if (this.readyState !== Transport.OPEN) {
        return false;
      }
      this.readyState = Transport.CLOSING;
      this.close_frame = closeFrame(status, reason);
      if (this.recv) {
        this.recv.doSendFrame(this.close_frame);
        if (this.recv) {
          return this.unregister;
        }
      }
    };
    Session.prototype.toString = function() {
      var r;
      r = ['#' + this.id];
      if (this.session_id) {
        r.push(this.session_id);
      }
      if (this.recv) {
        r.push(this.recv.protocol);
      }
      return r.join('/');
    };
    return Session;
  })();
  Session.bySessionId = function(session_id) {
    return MAP[session_id] || null;
  };
  Session.bySessionIdOrNew = function(session_id, server) {
    var session;
    session = Session.bySessionId(session_id);
    if (!session) {
      session = new Session(session_id, server);
    }
    return session;
  };
  GenericReceiver = (function() {
    function GenericReceiver(thingy) {
      this.thingy = thingy;
      this.setUp(this.thingy);
    }
    GenericReceiver.prototype.setUp = function() {
      this.thingy_end_cb = __bind(function() {
        return this.didClose(1006, "Connection closed");
      }, this);
      return this.thingy.addListener('end', this.thingy_end_cb);
    };
    GenericReceiver.prototype.tearDown = function() {
      this.thingy.removeListener('end', this.thingy_end_cb);
      return this.thingy_end_cb = null;
    };
    GenericReceiver.prototype.didClose = function(status, reason) {
      if (this.thingy) {
        this.tearDown(this.thingy);
        this.thingy = null;
      }
      if (this.session) {
        return this.session.unregister(status, reason);
      }
    };
    GenericReceiver.prototype.doSendBulk = function(messages) {
      if (messages.length === 1) {
        return this.doSendFrame('m' + JSON.stringify(messages[0]));
      } else {
        return this.doSendFrame('a' + JSON.stringify(messages));
      }
    };
    return GenericReceiver;
  })();
  ConnectionReceiver = (function() {
    __extends(ConnectionReceiver, GenericReceiver);
    function ConnectionReceiver(connection) {
      this.connection = connection;
      try {
        this.connection.setKeepAlive(true, 5000);
      } catch (x) {

      }
      ConnectionReceiver.__super__.constructor.call(this, this.connection);
    }
    ConnectionReceiver.prototype.doSendFrame = function(payload, encoding) {
      if (encoding == null) {
        encoding = 'utf-8';
      }
      if (!this.connection) {
        return false;
      }
      try {
        this.connection.write(payload, encoding);
        return true;
      } catch (e) {

      }
      return false;
    };
    ConnectionReceiver.prototype.didClose = function() {
      ConnectionReceiver.__super__.didClose.apply(this, arguments);
      try {
        this.connection.end();
      } catch (x) {

      }
      return this.connection = null;
    };
    return ConnectionReceiver;
  })();
  ResponseReceiver = (function() {
    __extends(ResponseReceiver, GenericReceiver);
    ResponseReceiver.prototype.max_response_size = void 0;
    function ResponseReceiver(response) {
      this.response = response;
      this.curr_response_size = 0;
      try {
        this.response.connection.setKeepAlive(true, 5000);
      } catch (x) {

      }
      ResponseReceiver.__super__.constructor.call(this, this.response.connection);
    }
    ResponseReceiver.prototype.doSendFrame = function(payload) {
      var r;
      this.curr_response_size += payload.length;
      r = false;
      try {
        this.response.write(payload);
        r = true;
      } catch (x) {

      }
      if (this.max_response_size && this.curr_response_size >= this.max_response_size) {
        this.didClose();
      }
      return r;
    };
    ResponseReceiver.prototype.didClose = function() {
      ResponseReceiver.__super__.didClose.apply(this, arguments);
      try {
        this.response.end();
      } catch (x) {

      }
      return this.response = null;
    };
    return ResponseReceiver;
  })();
  exports.Transport = Transport;
  exports.Session = Session;
  exports.ConnectionReceiver = ConnectionReceiver;
  exports.ResponseReceiver = ResponseReceiver;
}).call(this);
